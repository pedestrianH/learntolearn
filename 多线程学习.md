# 多线程学习

### juc概述

##### 进程

进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。

##### 线程

通常在一个进程中可以包含若干个线程，当然一个进程中至少有一个线程，不然没有存在的意义。线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和独立调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小得多，能更高效的提高系统多个程序间并发执行的程度

##### 线程与进程举例

 使用QQ，查看进程一定有一个QQ.exe的进程，我可以用qq和A文字聊天，和B视频聊天，给C传文件，给D发一段语言，QQ支持录入信息的搜索。写论文，用word写论文，同时用QQ音乐放音乐，同时用QQ聊天，多个进程。word如没有保存，停电关机，再通电后打开word可以恢复之前未保存的文档，word也会检查你的拼写，两个线程：容灾备份，语法检查

##### 状态

```java
Thread.State
public enum State {
  NEW,(新建)
 RUNNABLE,（准备就绪）
 BLOCKED,（阻塞）
WAITING,（不见不散）
TIMED_WAITING,（过时不候）
TERMINATED;(终结)
}
```

##### sleep和wait

功能都是当前线程暂停
wait放开手里的锁 等待
sleep手里还有锁等待

##### 并发并行区别

并发：同一时刻多个线程在访问同一个资源，多个线程对一个点

并行：多项工作一起执行，之后再汇总

### lock接口

##### 卖票

当不加同步锁时

```java
public class TicketOld {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
//        A线程想30
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <101 ; i++) {
                   ticket.sele();
                }
            }
        },"A线程").start();
        //        A线程想30
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <101 ; i++) {
                    ticket.sele();
                }
            }
        },"B线程").start();
        //        A线程想30
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <101 ; i++) {
                    ticket.sele();
                }
            }
        },"C线程").start();
    }

}
//资源类
class Ticket{
    private int number = 30;
    public  void sele(){
        if(number>0){
            number--;
            System.out.println(Thread.currentThread().getName()+"sale"+(30-number)+"还剩下"+number);
        }
}
}
```

结果

A线程sale1还剩下29
A线程sale2还剩下28
A线程sale3还剩下27
A线程sale4还剩下26
A线程sale5还剩下25
A线程sale6还剩下24
A线程sale7还剩下23
A线程sale8还剩下22
A线程sale9还剩下21
A线程sale10还剩下20
A线程sale11还剩下19
A线程sale12还剩下18
A线程sale13还剩下17
A线程sale14还剩下16
A线程sale15还剩下15
A线程sale16还剩下14
A线程sale17还剩下13
A线程sale18还剩下12
A线程sale19还剩下11
A线程sale20还剩下10
A线程sale21还剩下8
B线程sale22还剩下8
B线程sale24还剩下6
B线程sale25还剩下5
B线程sale26还剩下4
B线程sale27还剩下3
B线程sale28还剩下2
B线程sale29还剩下1
A线程sale23还剩下7
B线程sale30还剩下0

这样在执行时有重票 多线程操作同个类时 

解决 加 同步锁 

```java
public class TicketOld {
    public static void main(String[] args) {
        Ticket ticket = new Ticket();
//        A线程想30
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <101 ; i++) {
                   ticket.sele();
                }
            }
        },"A线程").start();
        //        A线程想30
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <101 ; i++) {
                    ticket.sele();
                }
            }
        },"B线程").start();
        //        A线程想30
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <101 ; i++) {
                    ticket.sele();
                }
            }
        },"C线程").start();
    }

}
//资源类
class Ticket{
    private int number = 30;
    public  synchronized void sele(){
        if(number>0){
            number--;
            System.out.println(Thread.currentThread().getName()+"sale"+(30-number)+"还剩下"+number);
        }
}
}
```

C线程sale1还剩下29
C线程sale2还剩下28
C线程sale3还剩下27
C线程sale4还剩下26
C线程sale5还剩下25
C线程sale6还剩下24
C线程sale7还剩下23
C线程sale8还剩下22
B线程sale9还剩下21
B线程sale10还剩下20
B线程sale11还剩下19
B线程sale12还剩下18
B线程sale13还剩下17
B线程sale14还剩下16
B线程sale15还剩下15
B线程sale16还剩下14
B线程sale17还剩下13
A线程sale18还剩下12
A线程sale19还剩下11
A线程sale20还剩下10
A线程sale21还剩下9
A线程sale22还剩下8
A线程sale23还剩下7
A线程sale24还剩下6
A线程sale25还剩下5
A线程sale26还剩下4
A线程sale27还剩下3
A线程sale28还剩下2
A线程sale29还剩下1
A线程sale30还剩下0

这样能构解决重票的问题

但这样在很大并发量的情形下 会使得该执行效率不够快 一线程在执行该操作时 会锁住该执行函数 

有时候需要锁住的对象只有很小的字段 因此将要缩小锁的范围

用新操作的lock

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class TicketNew {
    public static void main(String[] args) {
NewTicket newTicket = new NewTicket();

new Thread(()->{ for (int i = 0; i <30 ; i++) { newTicket.sele(); } },"A").start();
new Thread(()->{ for (int i = 0; i <30 ; i++) { newTicket.sele(); } },"B").start();
new Thread(()->{ for (int i = 0; i <30 ; i++) { newTicket.sele(); } },"C").start();

    }


}



//资源类
class NewTicket{
    private int number = 30;
    Lock lock = new ReentrantLock();

    public   void sele(){
        lock.lock();
        try {
            if(number>0){
                number--;
                System.out.println(Thread.currentThread().getName()+"sale"+(30-number)+"还剩下"+number);
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }

    }
}
```

### 通信



##### 生产者消费者

当被唤醒之后另个线程操作a已经加1 而当前线程在if之前判断过 直接往下走程序 再次执行价操作

```java
.防止虚假唤醒(判断只能用while，不能用if)
```

```java
public class ProAnc {

    public static void main(String[] args) {
        A a = new A();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    for (int i = 0; i <10 ; i++) {
                        a.add();
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"A").start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    for (int i = 0; i <10 ; i++) {
                        a.sub();
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"B").start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    for (int i = 0; i <10 ; i++) {
                        a.add();
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"C").start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    for (int i = 0; i <10 ; i++) {
                        a.sub();
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        },"K").start();
    }
}
class A{
    private int a = 0;
    public synchronized void  add() throws Exception {
        while (a!=0){
            //当前a=1则不需要进行加操作

            this.wait();

        }



        a++;
        System.out.println(Thread.currentThread().getName()+"a="+a);
        this.notifyAll();

    }
    public synchronized void  sub() throws Exception {
        while (a==0){
            //当前a=0则不需要进行减操作

            this.wait();

        }
        a--;
        System.out.println(Thread.currentThread().getName()+"a="+a);
        this.notifyAll();
    }

```

在执行这个加操作时 在等待的时候本来想要唤醒这减来操作 但让另个加执行了操作 当前线程又回来执行程序时本以为想要执行的减操作执行了 if只会进行判断一次 直接往下执行 又加一 因此为了虚假的唤醒线程 在判断这里需要循环 再次进行一次判断

lock版

```java
//新版写法可重入锁
    Lock lock = new ReentrantLock();
    private int a = 0;
    private Condition condition = lock.newCondition();

    public void add() throws Exception {
        lock.lock();
        try {
            //1.判断
            while (a != 0) {
                condition.await();
            }
            //2.干活
            a++;
            System.out.println(Thread.currentThread().getName() + "\t" + a);
            //3通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void sub() throws Exception {
        lock.lock();
        try {
            //1.判断
            while (a == 0) {
                condition.await();
            }
            //2.干活
            a--;
            System.out.println(Thread.currentThread().getName() + "\t" + a);
            //3通知
            condition.signalAll();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
```

##### 顺序精确地通知循环

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class 顺序循环打印 {
    public static void main(String[] args) {
        Lockfor lockfor = new Lockfor();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <10 ; i++) {
                    lockfor.printA();
                }
            }
        },"A").start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <10 ; i++) {
                    lockfor.printB();
                }
            }
        },"B").start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i <10 ; i++) {
                    lockfor.printC();
                }
            }
        },"C").start();
    }

}
class Lockfor{
    //标志
    private int a = 1;
    //锁对象
   private Lock lock = new ReentrantLock();
   private Condition conditionA = lock.newCondition();
   private Condition conditionB = lock.newCondition();
   private Condition conditionC = lock.newCondition();
   public void printA(){
        lock.lock();
        try {
            while(a!=1){
                conditionA.await();
            }
            for (int i = 0; i <5 ; i++) {
                System.out.println("A");
            }


            a = 2;
            conditionB.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
    public void printB(){
        lock.lock();
        try {
         while(a!=2){
            conditionB.await();
           }
            for (int i = 0; i <10 ; i++) {
                System.out.println("B");
            }


            a = 3;
            conditionC.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
          lock.unlock();
        }
    }
    public void printC(){
        lock.lock();
        try {
            while(a!=3){
                conditionC.await();
            }
            for (int i = 0; i <15 ; i++) {
                System.out.println("C");
            }


            a = 1;
            conditionA.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```

### 线程八锁

##### 1.标准

```java
public class 线程八锁 {

    public static void main(String[] args) {
        B b = new B();

        new Thread(new Runnable() {
            @Override
            public void run() {
                b.printA();
            }
        },"A").start();
        //A线程在B之前
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                b.printB();
            }
        },"B").start();
    }
}

class B {
    public synchronized void printA(){


//        try {
//            Thread.sleep(3000);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }
        System.out.println("A");
    }
    public synchronized void printB(){
        System.out.println("B");
    }
}
```

先打印A

  对象锁普通的同步
 *      一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，
 *      其他的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法，
 *      锁的是当前对象this，被锁定后，其他的线程都不能进入到当前对象的其他的synchronized方法




##### 2.在A中睡3000 先A还B

```java
    public synchronized void printA(){

  try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
```

A



##### 3.A睡3000 C为普通函数 

```java
  public synchronized void printA(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public synchronized void printB(){
        System.out.println("B");
    }
    public  void printC(){
 System.out.println("C");
    }
```

C

非synchronized的函数能够被同时调用

##### 4.两对象来操作 

```java
public class 线程八锁 {

    public static void main(String[] args) {
        B b = new B();
        B b1 = new B();
        new Thread(new Runnable() {
            @Override
            public void run() {
                b.printA();
            }
        },"A").start();
        //A线程在B之前
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                b1.printB();
            }
        },"B").start();
    }
}

class B {
    public synchronized void printA(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public synchronized void printB(){
        System.out.println("B");
    }
    public  void printC(){
 System.out.println("C");
    }
}
```

B

由于锁住的对象有两个



##### 5.两个静态同步函数 同个对象

```java
public class 线程八锁 {

    public static void main(String[] args) {
        B b = new B();
        B b1 = new B();
        new Thread(new Runnable() {
            @Override
            public void run() {
                b.printA();
            }
        },"A").start();
        //A线程在B之前
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                b.printB();
            }
        },"B").start();
    }
}

class B {
    public static synchronized void printA(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public  static synchronized void printB(){
        System.out.println("B");
    }
    public  void printC(){
 System.out.println("C");
    }
}
```

A

静态锁住的.class文件 

##### 6.两个静态同步函数 两个对象

```java
public class 线程八锁 {

    public static void main(String[] args) {
        B b = new B();
        B b1 = new B();
        new Thread(new Runnable() {
            @Override
            public void run() {
                b.printA();
            }
        },"A").start();
        //A线程在B之前
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                b1.printB();
            }
        },"B").start();
    }
}

class B {
    public static synchronized void printA(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public  static synchronized void printB(){
        System.out.println("B");
    }
    public  void printC(){
 System.out.println("C");
    }
}
```

A

静态锁住的.class文件 

##### 7.A为静态B非

```java
public class 线程八锁 {

    public static void main(String[] args) {
        B b = new B();
        B b1 = new B();
        new Thread(new Runnable() {
            @Override
            public void run() {
                b.printA();
            }
        },"A").start();
        //A线程在B之前
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                b.printB();
            }
        },"B").start();
    }
}

class B {
    public static synchronized void printA(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public   synchronized void printB(){
        System.out.println("B");
    }
    public  void printC(){
 System.out.println("C");
    }
}
```

B

两锁的不同对象 互相不干扰

##### 8.A为静态 B非 有两个对象

```java
public class 线程八锁 {

    public static void main(String[] args) {
        B b = new B();
        B b1 = new B();
        new Thread(new Runnable() {
            @Override
            public void run() {
                b.printA();
            }
        },"A").start();
        //A线程在B之前
        try {
            Thread.sleep(300);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        new Thread(new Runnable() {
            @Override
            public void run() {
                b1.printB();
            }
        },"B").start();
    }
}

class B {
    public static synchronized void printA(){
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("A");
    }
    public   synchronized void printB(){
        System.out.println("B");
    }
    public  void printC(){
 System.out.println("C");
    }
}
```

B

两锁的不同对象 互相不干扰

### nosafeclass

##### Arraylist

##### Vector

解决

1，用Collections.synchronizedList(new ArrayList<>())在内部能够实现加锁

2，new CopyOnWriteArrayList()写时复制

```java
  /**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return {@code true} (as specified by {@link Collection#add})
     */
    public boolean add(E e) {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            Object[] elements = getArray();
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len + 1);
            newElements[len] = e;
            setArray(newElements);
            return true;
        } finally {
            lock.unlock();
```

##### HashSet

##### 写时复制



 *  CopyOnWrite容器即写时复制的容器。往一个容器添加元素的时候，不直接往当前容器Object[]添加，而是现将当前容器Object[]进行Copy，
 *  复制出一个新的容器Object[] newElements，然后新的容器Object[] newElements里添加元素，添加完元素之后，
 *  再将原容器的引用指向新的容器setArray(newElements);。这样做的好处是可以对CopyOnWrite容器进行并发的读，
 *  而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器
 

### Callable

能够获取线程

通过futuretask和Runable进行适配

##### futuretask

在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给Future对象在后台完成，
当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执行状态。

一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。

仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，
就不能再重新开始或取消计算。get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，
然后会返回结果或者抛出异常。 

只计算一次
get方法放到最后

### CountDownLatchDemo

* CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这些线程会阻塞。
 * 其它线程调用countDown方法会将计数器减1(调用countDown方法的线程不会阻塞)，
 * 当计数器的值变为0时，因await方法阻塞的线程会被唤醒，继续执行。

```java
public class CountDownLatchDemo
{
   public static void main(String[] args) throws InterruptedException
   {
         CountDownLatch countDownLatch = new CountDownLatch(6);
       
       for (int i = 1; i <=6; i++) //6个上自习的同学，各自离开教室的时间不一致
       {
          new Thread(() -> {
              System.out.println(Thread.currentThread().getName()+"\t 号同学离开教室");
              countDownLatch.countDown();
          }, String.valueOf(i)).start();
       }
       countDownLatch.await();
       System.out.println(Thread.currentThread().getName()+"\t****** 班长关门走人，main线程是班长");
          
   }

```

### CyclicBarrierDemo

```java
/**
 * 
 * @Description: TODO(这里用一句话描述这个类的作用)  
 *
 * CyclicBarrier
 * 的字面意思是可循环（Cyclic）使用的屏障（Barrier）。它要做的事情是，
 * 让一组线程到达一个屏障（也可以叫同步点）时被阻塞，
 * 直到最后一个线程到达屏障时，屏障才会开门，所有
 * 被屏障拦截的线程才会继续干活。
 * 线程进入屏障通过CyclicBarrier的await()方法。
 * 
 * 集齐7颗龙珠就可以召唤神龙
 */
public class CyclicBarrierDemo
{
  private static final int NUMBER = 7;
  
  public static void main(String[] args)
  {
     //CyclicBarrier(int parties, Runnable barrierAction) 
     
     CyclicBarrier cyclicBarrier = new CyclicBarrier(NUMBER, ()->{System.out.println("*****集齐7颗龙珠就可以召唤神龙");}) ;
     
     for (int i = 1; i <= 7; i++) {
       new Thread(() -> {
          try {
            System.out.println(Thread.currentThread().getName()+"\t 星龙珠被收集 ");
            cyclicBarrier.await();
          } catch (InterruptedException | BrokenBarrierException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
          }
       
       }, String.valueOf(i)).start();
     }
     
 
  }
}
```

### SemaphoreDemo

```java
/**
 * 
 * @Description: TODO(这里用一句话描述这个类的作用)  
 * 
 * 在信号量上我们定义两种操作：
 * acquire（获取） 当一个线程调用acquire操作时，它要么通过成功获取信号量（信号量减1），
 *             要么一直等下去，直到有线程释放信号量，或超时。
 * release（释放）实际上会将信号量的值加1，然后唤醒等待的线程。
 * 
 * 信号量主要用于两个目的，一个是用于多个共享资源的互斥使用，另一个用于并发线程数的控制。
 */
public class SemaphoreDemo
{
  public static void main(String[] args)
  {
     Semaphore semaphore = new Semaphore(3);//模拟3个停车位
      for (int i = 1; i <=6; i++) //模拟6部汽车
     {
       new Thread(() -> {
          try 
          {
            semaphore.acquire();
            System.out.println(Thread.currentThread().getName()+"\t 抢到了车位");
            TimeUnit.SECONDS.sleep(new Random().nextInt(5));
            System.out.println(Thread.currentThread().getName()+"\t------- 离开");
          } catch (InterruptedException e) {
            e.printStackTrace();
          }finally {
            semaphore.release();
          }
       }, String.valueOf(i)).start();
     }
 }
}

```

### ReadWriteLockDemo

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;

class MyCache{
    private volatile Map<String,Object> map = new HashMap<>();
    public void put(String key,Object value){
        System.out.println(Thread.currentThread().getName()+"\t 正在写"+key);
        //暂停一会儿线程
        try {TimeUnit.MILLISECONDS.sleep(300);} catch (InterruptedException e) {e.printStackTrace(); }
        map.put(key,value);
        System.out.println(Thread.currentThread().getName()+"\t 写完了"+key);
    }
 public Object get(String key){
        Object result = null;
        System.out.println(Thread.currentThread().getName()+"\t 正在读"+key);
        try {TimeUnit.MILLISECONDS.sleep(300);} catch (InterruptedException e) {e.printStackTrace(); }
        result = map.get(key);
        System.out.println(Thread.currentThread().getName()+"\t 读完了"+result);
        return result;
    }
}
public class ReadWriteLockDemo {
public static void main(String[] args) {
        MyCache myCache = new MyCache();
  for (int i = 1; i <= 5; i++) {
            final int num = i;
            new Thread(()->{
                myCache.put(num+"",num+"");
            },String.valueOf(i)).start();
        }
        for (int i = 1; i <= 5; i++) {
            final int num = i;
            new Thread(()->{
                myCache.get(num+"");
            },String.valueOf(i)).start();
        }
  }
}
```

解决

```java
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

class MyCache {
    private volatile Map<String, Object> map = new HashMap<>();
    private ReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void put(String key, Object value) {
        rwLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在写" + key);
            //暂停一会儿线程
            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "\t 写完了" + key);
            System.out.println();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            rwLock.writeLock().unlock();
        }

    }

    public Object get(String key) {
        rwLock.readLock().lock();
        Object result = null;
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在读" + key);
            try {
                TimeUnit.MILLISECONDS.sleep(300);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            result = map.get(key);
            System.out.println(Thread.currentThread().getName() + "\t 读完了" + result);
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            rwLock.readLock().unlock();
        }
        return result;
    }
}

public class ReadWriteLockDemo {


    public static void main(String[] args) {
        MyCache myCache = new MyCache();

        for (int i = 1; i <= 5; i++) {
            final int num = i;
            new Thread(() -> {
                myCache.put(num + "", num + "");
            }, String.valueOf(i)).start();
        }
        for (int i = 1; i <= 5; i++) {
            final int num = i;
            new Thread(() -> {
                myCache.get(num + "");
            }, String.valueOf(i)).start();
        }

    }


}
  
```

### 队列

```java

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * 阻塞队列
 */
public class BlockingQueueDemo {

    public static void main(String[] args) throws InterruptedException {

//        List list = new ArrayList();

        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
        //第一组
//        System.out.println(blockingQueue.add("a"));
//        System.out.println(blockingQueue.add("b"));
//        System.out.println(blockingQueue.add("c"));
//        System.out.println(blockingQueue.element());

        //System.out.println(blockingQueue.add("x"));
//        System.out.println(blockingQueue.remove());
//        System.out.println(blockingQueue.remove());
//        System.out.println(blockingQueue.remove());
//        System.out.println(blockingQueue.remove());
//    第二组
//        System.out.println(blockingQueue.offer("a"));
//        System.out.println(blockingQueue.offer("b"));
//        System.out.println(blockingQueue.offer("c"));
//        System.out.println(blockingQueue.offer("x"));
//        System.out.println(blockingQueue.poll());
//        System.out.println(blockingQueue.poll());
//        System.out.println(blockingQueue.poll());
//        System.out.println(blockingQueue.poll());
//    第三组        
//         blockingQueue.put("a");
//         blockingQueue.put("b");
//         blockingQueue.put("c");
//         //blockingQueue.put("x");
//        System.out.println(blockingQueue.take());
//        System.out.println(blockingQueue.take());
//        System.out.println(blockingQueue.take());
//        System.out.println(blockingQueue.take());
        
//    第四组        
        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("b"));
        System.out.println(blockingQueue.offer("c"));
        System.out.println(blockingQueue.offer("a",3L, TimeUnit.SECONDS));

    }
}



```

