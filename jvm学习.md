# jvm上篇尚硅谷

### 第一章 VM与Java体系结构

##### 1，跨平台

![jvm-1跨平台](D:\学习Java\linux\csdn\jvm-1跨平台.png)

不同的计算机语言都能够用Java虚拟机来解释执行程序翻译为机器指令

##### 2，特点

- 自动内存管理
- 一次编译、到处运行
- 自动拉机回收功能

##### 3，所在的位置

![jvm-1.位置](D:\学习Java\linux\csdn\jvm-1.位置.png)

##### 4，整体的结构

![jvm-1整体的架构](D:\学习Java\linux\csdn\jvm-1整体的架构.jpg)

##### 5,程序执行的流程

![jvm-1流程](D:\学习Java\linux\csdn\jvm-1流程.jpg)

##### 6，架构的类型

编译器一般地来说有两种架构类型

- Java采用的为于栈的架构

不要硬件的支持 移植性好些 

- 令一种则采用的为寄存器的架构

这种类型的架构依赖硬件 直接与硬件进行交互 因此运行的效率很快

![jvm-1架构](D:\学习Java\linux\csdn\jvm-1架构.jpg)

##### 7，生命的周期

![jvm-1周期](D:\学习Java\linux\csdn\jvm-1周期.jpg)



### 第二章类加载子系统

##### 1，内存结构概述

##### 2，类加载过程

![jvm-1过程](D:\学习Java\linux\csdn\jvm-1过程.jpg)

这里主要有三个过程

- loding

首先由引导类、扩展类、系统类三种类加载器来进行将类loading进来

通常为以流的形式

- linking

![jvm-1linking](D:\学习Java\linux\csdn\jvm-1linking.jpg)



- initialization

![jvm-1initialization](D:\学习Java\linux\csdn\jvm-1initialization.jpg)



##### 3，加载器的类型

主要包含了这三种

- 引导类

![jvm-1引导类](D:\学习Java\linux\csdn\jvm-1引导类.jpg)

- 扩展类

![](.\引图片\2.jpg)

- 系统类

![](.\引图片\3.jpg)

而且咱还能够自定义

![](.\引图片\5.jpg)

再了解下它的class loader 的获取

![](.\引图片\6.jpg)

##### 双亲委派机制

Java类都在被需要时才会被loader 

且在这个过程中有着这样形式

![](.\引图片\7.jpg)

![](.\引图片\8.jpg)

![](.\引图片\9.jpg)

##### 沙箱安全机制

![](.\引图片\10.jpg)

##### 补充

![](.\引图片\11.jpg)

![](.\引图片\12.jpg)

##### 类的主动使用和被动使用

![](.\引图片\13.jpg)

### 第三章运行区数据区概述及线程

##### 运行时数据区内部结构

![](.\引图片\14.jpg)

详细

![](.\引图片\15.jpg)

 再详细的结构图

![](.\引图片\16.jpg)

##### 线程

![](.\引图片\17.jpg)

与操作系统的关系

![](.\引图片\18.jpg)

系统线程

![](.\引图片\19.jpg)

### 第四章程序计数器

##### 概述

![](.\引图片\30.jpg)

![](.\引图片\31.jpg)

![](.\引图片\32.jpg)

执行流程

![](.\引图片\38.jpg)

##### 常见问题

一

![](.\引图片\39.jpg)

二

![](.\引图片\57.jpg)

CPU时间片

![y](.\引图片\101.jpg)

### 第五章虚拟机栈

![](.\引图片\102.jpg)

##### 栈与堆的内存关系

![](.\引图片\103.jpg)

##### 内容

![](.\引图片\105.jpg)

##### 栈的特点

![](.\引图片\106.jpg)

##### 开发中有哪些异常

![](.\引图片\107.jpg)

stackoverflow

```java
public class StackErrorTest {
    private static int count = 1;
    public static void main(String[] args) {
        System.out.println(count);
        count++;
        main(args);
    }

}
```

内存设置的栈空间大小不够 会报错

设置了这个一定的栈空间比运行时调用需要的空间大择不会报错

##### 栈的存储单位

![](.\引图片\108.jpg)

##### 栈运行的原理

![](.\引图片\109.jpg)

![](.\引图片\117.jpg)

栈返回的几种形式

![](.\引图片\131.jpg)

![](.\引图片\栈帧的内部结构.jpg)

##### 局部变量表

![](.\引图片\局部变量表.jpg)

![](.\引图片\作用域.jpg)

##### slot插槽的理解

![](.\引图片\插槽.jpg)

![](.\引图片\this实例对.jpg)

如静态的函数不能够来调用实例函数的this  因为this存在于实例函数和构造函数

重复利用的

![](.\引图片\重复利用的.jpg)

##### 静态变量与局部变量区别

![](.\引图片\对比.jpg)

局部变量要人为手动设置值 

补充

![](.\引图片\补充.jpg)

##### 操作数栈

![](.\引图片\操作数栈.jpg)

![](.\引图片\操作数栈执行程序指令.jpg)

![](.\引图片\概念的.jpg)

![](.\引图片\栈.jpg)

##### 栈顶缓存

![](.\引图片\栈顶缓存.jpg)

##### 动态链接

![](.\引图片\动态链接.jpg)

符号引用

![](.\引图片\符号引用.jpg)

真实结构

![](.\引图片\真实结构.jpg)

一程序的执行要很多的类 要在执行时将其全部加入栈里 占用的空间太大 因此只用个引用来指向所要用的类

![](.\引图片\常量池.jpg)

常量池提供了符号和常量 便于指令的识别

##### 函数的绑定调用(静态链接和动态链接)

![](.\引图片\调用.jpg)

![](.\引图片\绑定.jpg)

##### 虚方法和非虚方法

![](.\引图片\非虚.jpg)

多态的条件这里都要 静态的不能够被重写

![](.\引图片\多态的条件这里都要.jpg)

区别

![](.\引图片\区别.jpg)

![](.\引图片\调用非虚.jpg)

invokedynamic指令

![](.\引图片\invokedynamic指令.jpg)

##### 重写的本质

![](.\引图片\重写的本质.jpg)

##### 虚方法表

![](.\引图片\虚方法表.jpg)

![](.\引图片\虚表.jpg)

##### 方法返回地址

![](.\引图片\返回.jpg)

正常的与非正常调用

![](.\引图片\正常的与非正常调用.jpg)

![](.\引图片\返回的一些指令.jpg)

异常处理表

![](.\引图片\异常处理表.jpg)

##### 一些附加信息

![](.\引图片\信息.jpg)

##### 问题

![](.\引图片\问题.jpg)

### 第六章本地方法接口

![](.\引图片\本地.jpg)

能用Java的所有标识符 但abstract不能用

![](.\引图片\为啥要.jpg)

本地与操作系统交互

![](.\引图片\本地与操作系统交互.jpg)

### 第七章本地方法栈

![](.\引图片\本地栈.jpg)

![](.\引图片\执行流程.jpg)

![](.\引图片\支持栈.jpg)

### 第八章堆

##### 堆概述

![](.\引图片\堆.jpg)

![](.\引图片\堆概述.jpg)

内存

![](.\引图片\内存类.jpg)

##### 设置堆内存大小与内存溢出异常

![](.\引图片\设置大小.jpg)

##### 少年代与老年代

![](.\引图片\其类型.jpg)

占比参数

![](.\引图片\占比参数.jpg)

![](.\引图片\新生占.jpg)

##### 对象分配的过程概述

![](.\引图片\对象分配的过程概述.jpg)

![](.\引图片\过程配.jpg)

![](.\引图片\配总结.jpg)

流程图

![](.\引图片\流程图.jpg)

##### minor gc major gc full gc

![](.\引图片\gc.jpg)

新生代 gc触发机制

![](.\引图片\触发.jpg)

![](.\引图片\来回切.jpg)

这里的1和2在存储一次对象时将会来回徘徊直到=thresgold

老年代触发机制

![](.\引图片\老年代触发机制.jpg)

fullgc触发

![](.\引图片\fullgc触发.jpg)

##### 堆空间的划区思想

![](.\引图片\划区.jpg)

##### 内存分配策略

![](.\引图片\规则.jpg)

![](.\引图片\还能通过这个来划区.jpg)

##### 堆空间的线程都有tlab

![](.\引图片\线程独有的.jpg)

![](.\引图片\内存区.jpg)

对象分配的过程

![](.\引图片\对象分配的过程.jpg)

当不会在这个tlab中分配了内存则系统会

![](.\引图片\内存锁.jpg)

完整对象的分配过程

![](.\引图片\完整对象的分配过程.jpg)

##### 小结堆空间的常用参数设置

![](.\引图片\堆参数.jpg)

![](.\引图片\参数堆.jpg)

![](.\引图片\堆总结.jpg)

##### 通过逃逸分析看堆空间的对象分配

堆不为这个分配对象的唯一选择

![](.\引图片\堆唯一.jpg)

逃逸分析概述

![](.\引图片\逃逸.jpg)

程序

![](.\引图片\逃逸程.jpg)

参数设置逃逸分析

![](.\引图片\参数设置逃逸分析.jpg)

结论

![](.\引图片\结论.jpg)

##### 优化

![](.\引图片\优化.jpg)

 栈上分配

![](.\引图片\栈上分配规则.jpg)

同步省略

![](.\引图片\同步省略.jpg)

![](.\引图片\省略程.jpg)

标量替换

![](.\引图片\标量替换.jpg)

![](.\引图片\替换之后了.jpg)

标量参数设置

![](.\引图片\标量参数设置.jpg)

![](.\引图片\参数.jpg)

### 第九章方法区

##### 交互关系

![](.\引图片\结构.jpg)

![](.\引图片\共享.jpg)

![](.\引图片\程序来.jpg)

##### 方法区的理解

![](.\引图片\概念.jpg)

##### 演进

![](.\引图片\演进.jpg)

![](.\引图片\概述对比.jpg)

![](.\引图片\元空间.jpg)

##### 设置方法区大小的参数

之前设置的规则

![](.\引图片\之前的设置规则.jpg)

现在

![](.\引图片\设置内存的.jpg)

程序

![](.\引图片\程序报错溢出.jpg)

解决

内存泄露在堆中有对象 有引用指向它 但在执行的程序不会用到它

![](.\引图片\解决.jpg)



##### 内部存储结构

![](.\引图片\存储内.jpg)

类型信息

![](.\引图片\类型信息.jpg)

域

![](.\引图片\域.jpg)

保存的信息

![](.\引图片\保存的信息.jpg)

类变量

![](.\引图片\类变量.jpg)

全局常量 

![](.\引图片/全局常量.jpg)

##### 常量池

常量池在文件中的位置

![](.\引图片\常量池在文件中的位置.jpg)

常量池存储的数据

![](.\引图片\常量池存储的数据.jpg)

小结

![](.\引图片\小结.jpg)

##### 运行时常量池

![](.\引图片\运行时常量池.jpg)

常量池执行流程

![](.\引图片\常量池执行流程.jpg)

##### 变化

![](.\引图片\变化.jpg)

![](.\引图片\内存构.jpg)

![](.\引图片\内存.jpg)

![](.\引图片\现在.jpg)

元空间的内存在本地

##### stringtable调整位置

![](.\引图片\stringtable.jpg)

##### gc

![](.\引图片\gc收集.jpg)

![](.\引图片\常量.jpg)

被回收

![](.\引图片\被回收.jpg)

##### 问题

![](.\引图片\常量的问题.jpg)

![](.\引图片\常见常量的问题.jpg)

### 第十章对象的实例化内存布局与访问定位

##### 对象实例化的问题

![](.\引图片\对象实例化的问题.jpg)

##### 对象的实例化

![](.\引图片\对象的实例化.jpg)

##### 对象的内存布局

![](.\引图片\对象的内存布局.jpg)

![](.\引图片\内存布局.jpg)

##### 对象访问定位

![](.\引图片\对象访问定位.jpg)

怎样访问到从栈帧到堆再元空间

![](.\引图片\对象实例在内部.jpg)

句柄访问

![](.\引图片\句柄访问.jpg)

直接指针

![](.\引图片\直接指针.jpg)

### 第十一章直接内存

##### 概述

![](.\引图片\直接内存.jpg)

![](.\引图片\直接.jpg)

系统的内存被用完同样报错

![](.\引图片\报错.jpg)

直接内存与内存的关系

![](.\引图片\直接内存与内存的关系.jpg)

### 第十二章执行引擎

##### 概述

![](.\引图片\执行引擎概述.jpg)

执行引擎对比
![](.\引图片\执行引擎对比.jpg)

作用

![](.\引图片\作用.jpg)

执行引擎的工作过程

![](.\引图片\执行引擎的工作过程.jpg)

##### 程序编译还有执行的过程

![](.\引图片\编译和执行的过程.jpg)

编译

![](.\引图片\流程编译程序执行.jpg)

执行

![](.\引图片\执行.jpg)

解释器与编译对比

![](.\引图片\解释器与编译对比.jpg)

解释与编译同时进行

![](.\引图片\同时.jpg)

##### 机器码 汇编 指令

![](.\引图片\汇编.jpg)

 ##### 解释器

概念

![](.\引图片\解释器.jpg)

任务

![](.\引图片\任务.jpg)

类别

![](.\引图片\类别.jpg)

##### 编译器

![](.\引图片\编译器.jpg)

![](.\引图片\有好处.jpg)

热点探测

![](.\引图片\热点探测.jpg)

前端编译为 .java -> .class

后端编译为 .class  能够执行的语言

![](.\引图片\热点探.jpg)

![](.\引图片\怎样探测.jpg)

调用计数器

![](.\引图片\调用计数器.jpg)

![](.\引图片\其对编译计数的调用.jpg)

减

![](.\引图片\减.jpg)

##### 回边

![](.\引图片\回边.jpg)

![](.\引图片\会变加.jpg)

选择执行的参数

![](.\引图片\选择执行的参数.jpg)

编译类型

![](.\引图片\编译类型.jpg)

![](.\引图片\分层编译.jpg)

不同的优化策略

![](.\引图片\不同的优化策略.jpg)

总结

![](.\引图片\总结.jpg)

![](.\引图片\新.jpg)

![](.\引图片\新型的.jpg)

![](.\引图片\缺点.jpg)

### 第十三章stringtable

##### 特性

![](.\引图片\特性.jpg)

存储结构

![](.\引图片\存储结构.jpg)

![](.\引图片\不变.jpg)

![](.\引图片\不存储一样的字符串.jpg)



### 理论程序再加总结

